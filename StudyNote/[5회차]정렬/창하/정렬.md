# 정렬 알고리즘의 특징

데이터 사이에는 유사한 속성이나 일련의 순서가 있습니다. 이는 많은 컴퓨팅 알고리즘에서 데이터를 특정 형태로 정렬할 필요가 있음을 의미합니다. 예를 들어 이진 탐색 알고리즘은 데이터를 특정 순서로 배열해야 비교를 통해 빠르게 검색할 수 있습니다. 데이터베이스에서도 쿼리를 실행할 때 특정 속성에 따라 데이터를 정렬하는 경우가 흔합니다. 데이터를 정렬하면 중복된 데이터를 빠르게 식별하거나 필요한 데이터를 빠르게 찾을 수 있습니다.

## 일반적인 정렬 알고리즘

프로그래밍할 때는 많은 언어에서 제공하는 라이브러리 함수를 활용하므로 내부 동작보다는 개념적인 이해에 중점을 두는 것이 유용합니다.

1. **버블 정렬 (Bubble Sort):** 인접한 두 원소를 비교하며 정렬하는 간단한 알고리즘입니다.

2. **선택 정렬 (Selection Sort):** 배열에서 가장 작은(또는 가장 큰) 원소를 찾아 제일 앞(또는 제일 뒤)으로 이동시키는 방식으로 정렬합니다.

3. **삽입 정렬 (Insertion Sort):** 배열을 순차적으로 순회하면서 각 원소를 정렬된 부분 배열에 삽입하여 정렬하는 알고리즘입니다.

4. **병합 정렬 (Merge Sort):** 배열을 반으로 나눈 후, 각 부분 배열을 재귀적으로 정렬하고 합병하여 정렬하는 방식입니다.

5. **퀵 정렬 (Quick Sort):** 배열에서 피벗(pivot)을 선택하여 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 나누어 정렬하는 알고리즘입니다.

## <span style="color:yellow">버블 정렬 (Bubble Sort)</span>

버블 정렬은 가장 기초적이면서 이해하기 쉬운 정렬 알고리즘 중 하나입니다. 이 알고리즘은 순차적으로 인접한 두 원소를 비교하면서 필요에 따라 위치를 교환하여 정렬을 진행합니다.

## 동작 과정

1. 주어진 배열에서 인접한 두 원소를 순차적으로 비교합니다.
2. 만약 오른쪽의 원소가 왼쪽의 원소보다 작다면 두 원소의 위치를 교환합니다.
3. 배열의 끝까지 이동하면서 가장 큰 원소가 배열의 마지막으로 이동하게 됩니다.
4. 정렬된 부분을 제외하고 나머지 부분에 대해 위 과정을 반복합니다.
5. 정렬이 완료될 때까지 위의 과정을 반복합니다.

## 예시

다음은 버블 정렬이 진행되는 예시입니다. 주어진 배열: 10 18 6 2 4 16 8 14 12

1. 14와 12를 비교하여 위치 교환: 10 18 6 2 4 16 8 12 14
2. 8과 12를 비교하여 위치 유지: 10 18 6 2 4 16 8 12 14
3. 16과 8을 비교하여 위치 교환: 10 18 6 2 4 8 16 12 14
4. ...

위 과정을 반복하여 정렬이 완료되면 결과는 다음과 같습니다: 2 4 6 8 10 12 14 16 18

버블 정렬은 간단하지만 시간 복잡도가 O(n^2)으로 느리기 때문에 대규모 데이터에는 적합하지 않습니다.

## <span style="color:yellow">선택 정렬 (Selection Sort)</span>

선택 정렬은 선형 탐색을 활용한 간단한 정렬 알고리즘 중 하나입니다. 아래의 예시를 통해 선택 정렬의 동작을 살펴보겠습니다.

## 동작 과정

주어진 배열: 12 4 14 16 18 6 10 8 2

1. 배열에서 가장 작은 숫자 2를 선형 탐색을 통해 찾습니다.
    - 배열 상태: 12 4 14 16 18 6 10 8 2
2. 가장 작은 숫자 2와 배열의 가장 왼쪽 숫자 12의 위치를 교환합니다.
    - 배열 상태: 2 4 14 16 18 6 10 8 12
3. 이제 정렬이 완료된 부분을 제외하고 나머지 부분에서 위 과정을 반복합니다.
    - 배열 상태: 2 4 6 8 10 12 14 16 18

## 특징

- 선택 정렬은 이해하기 쉽지만 시간 복잡도가 $$O(n^{2})$$)으로 비효율적입니다.
- 배열의 가장 작은 숫자를 찾기 위해 선형 탐색을 사용하므로 입력 데이터가 많을수록 속도가 느려집니다.

선택 정렬은 작은 배열에서는 잘 동작하지만, 대규모 데이터에는 적합하지 않습니다.


## <span style="color:yellow">삽입 정렬 (Insertion Sort)</span>

삽입 정렬은 간단하면서도 효율적인 정렬 알고리즘 중 하나입니다. 동작은 다음과 같습니다.

1. 배열의 두 번째 숫자부터 시작하여 왼쪽의 숫자들과 비교합니다.
2. 비교하면서 자리를 찾아가며 숫자를 삽입합니다.
3. 배열의 모든 숫자가 정렬될 때까지 위 과정을 반복합니다.

예시:
주어진 배열: 10 6 8 14 4 16 12 18 2
정렬된 배열: 2 4 6 8 10 12 14 16 18

삽입 정렬은 시간 복잡도가 최악의 경우 O(n^2)이지만, 작은 데이터셋에 대해서는 효율적입니다.

## <span style="color:yellow">셸 정렬 (Shell Sort)</span>

셸 정렬은 삽입 정렬을 보다 효율적으로 실행하는 알고리즘입니다. 다음과 같은 방식으로 동작합니다.

1. 일정한 간격의 요소들을 묶어 삽입 정렬을 실행합니다.
2. 간격을 줄여가면서 삽입 정렬을 반복합니다.
3. 간격이 1이 될 때까지 위 과정을 반복하여 정렬을 완료합니다.

예시:
주어진 배열: 10 6 8 14 4 16 12 20 18 2 22
정렬된 배열: 2 4 6 8 10 12 14 16 18 20 22

셸 정렬은 삽입 정렬에 비해 평균적으로 더 빠른 성능을 보이며, 시간 복잡도는 $$O(n^{1.5})$$ 정도로 추정됩니다.

## <span style="color:yellow">삽입 정렬과 셸 정렬의 시간 복잡도 비교</span>
| 알고리즘   | 최선       | 평균        | 최악        |
|------------|------------|-------------|-------------|
| 삽입 정렬 | O(n)       | O(n^2)      | O(n^2)      |
| 셸 정렬   | O(n)       | O(n^1.5)    | O(n^2)      |

## <span style="color:yellow">병합 정렬</span>


병합 정렬(merge sort)은 데이터를 반으로 나누어 정렬을 수행하는 독창적인 알고리즘으로, 이를 분할 정복(divide and conquer)이라고 합니다.

병합 정렬의 과정을 이해하기 위해 주어진 정렬되지 않은 짝수의 배열을 살펴보겠습니다.

1. **배열을 반으로 나누기:**

    - 주어진 배열: 12 8 6 14 10 2 4
    - 반으로 나눈 배열: 12 8 4 / 6 14 10 2
2. **배열을 더 이상 나눌 수 없을 때까지 반복:**

    - 12 8 4를 더 나눔: 12 / 8 / 4
    - 6 14 10 2를 더 나눔: 6 / 14 / 10 2
3. **두 배열을 결합하며 정렬:**

    - 두 배열을 작은 숫자에서 큰 숫자 순으로 결합: 8 12 / 6 14 2 10 4
    - 결합된 배열을 다시 정렬: 6 8 12 14 2 4 10
4. **반복적인 결합과 정렬:**

    - 더 큰 범위의 배열을 결합하며 반복: 6 8 12 14 / 2 4 10
    - 최종적으로 완전히 정렬된 배열 얻음: 2 4 6 8 10 12 14

병합 정렬은 재귀 함수를 사용하여 입력 데이터를 계속 나누기 때문에 시간 복잡도가 $$O(nlogn)$$입니다. 이는 배열을 반으로 나누고 정렬하는 과정이 로그 시간 복잡도를 갖기 때문입니다. 