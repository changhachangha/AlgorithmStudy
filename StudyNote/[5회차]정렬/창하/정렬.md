# 정렬 알고리즘의 특징

데이터 사이에는 유사한 속성이나 일련의 순서가 있습니다. 이는 많은 컴퓨팅 알고리즘에서 데이터를 특정 형태로 정렬할 필요가 있음을 의미합니다. 예를 들어 이진 탐색 알고리즘은 데이터를 특정 순서로 배열해야 비교를 통해 빠르게 검색할 수 있습니다. 데이터베이스에서도 쿼리를 실행할 때 특정 속성에 따라 데이터를 정렬하는 경우가 흔합니다. 데이터를 정렬하면 중복된 데이터를 빠르게 식별하거나 필요한 데이터를 빠르게 찾을 수 있습니다.

## 일반적인 정렬 알고리즘

프로그래밍할 때는 많은 언어에서 제공하는 라이브러리 함수를 활용하므로 내부 동작보다는 개념적인 이해에 중점을 두는 것이 유용합니다.

1. **버블 정렬 (Bubble Sort):** 인접한 두 원소를 비교하며 정렬하는 간단한 알고리즘입니다.

2. **선택 정렬 (Selection Sort):** 배열에서 가장 작은(또는 가장 큰) 원소를 찾아 제일 앞(또는 제일 뒤)으로 이동시키는 방식으로 정렬합니다.

3. **삽입 정렬 (Insertion Sort):** 배열을 순차적으로 순회하면서 각 원소를 정렬된 부분 배열에 삽입하여 정렬하는 알고리즘입니다.

4. **병합 정렬 (Merge Sort):** 배열을 반으로 나눈 후, 각 부분 배열을 재귀적으로 정렬하고 합병하여 정렬하는 방식입니다.

5. **퀵 정렬 (Quick Sort):** 배열에서 피벗(pivot)을 선택하여 피벗보다 작은 원소는 왼쪽, 큰 원소는 오른쪽으로 나누어 정렬하는 알고리즘입니다.

## <span style="color:yellow">버블 정렬 (Bubble Sort)</span>

버블 정렬은 가장 기초적이면서 이해하기 쉬운 정렬 알고리즘 중 하나입니다. 이 알고리즘은 순차적으로 인접한 두 원소를 비교하면서 필요에 따라 위치를 교환하여 정렬을 진행합니다.

## 동작 과정

1. 주어진 배열에서 인접한 두 원소를 순차적으로 비교합니다.
2. 만약 오른쪽의 원소가 왼쪽의 원소보다 작다면 두 원소의 위치를 교환합니다.
3. 배열의 끝까지 이동하면서 가장 큰 원소가 배열의 마지막으로 이동하게 됩니다.
4. 정렬된 부분을 제외하고 나머지 부분에 대해 위 과정을 반복합니다.
5. 정렬이 완료될 때까지 위의 과정을 반복합니다.

## 예시

다음과 같은 짝수의 배열이 있습니다.

![[Pasted image 20240204011811.png]](img/Pasted image 20240204011811.png)

배열 오른쪽 끝에 있는 두 숫자 14와 12를 확인합니다.

![[Pasted image 20240204012524.png]](img/Pasted image 20240204012524.png)

두 숫자를 비교하여 오른쪽이 왼쪽보다 작으면 두 숫자의 위치를 바꿉니다. 두 숫자의 위치가 바뀐 새로운 배열은 다음과 같습니다.

![[Pasted image 20240204012644.png]](img/Pasted image 20240204012644.png)

왼쪽으로 한 자리 이동한 다음 두 숫자 8과 12를 비교합니다.

![[Pasted image 20240204012836.png]](img/Pasted image 20240204012836.png)

두 숫자를 비교하면 오른쪽이 왼쪽보다 큽니다. 따라서 두 숫자의 위치를 바꾸지 않습니다.

![[Pasted image 20240204013214.png]](img/Pasted image 20240204013214.png)

계속해서 한 자리씩 왼쪽으로 이동하며 배열의 왼쪽 끝에 도달할 때까지 두 숫자를 비교합니다. 그 결과 배열 상태는 다음과 같이 됩니다.

![[Pasted image 20240204013119.png]](img/Pasted image 20240204013119.png)

결국 배열에서 가장 작은 숫자가 배열의 가장 왼쪽으로 이동하게 됩니다. 그럼 숫자 2는 정렬이 완료된 것으로 간주합니다. 이제 알고리즘은 다시 배열의 오른쪽 끝으로 돌아가 두 숫자를 비교합니다.

![[Pasted image 20240204013649.png]](img/Pasted image 20240204013649.png)

배열의 요소가 모두 정렬될 때까지 앞 과정을 반복해 알고리즘이 계속 실행되면 다음과 같이 정렬된 배열을 얻을 수 있습니다.

![[Pasted image 20240204013504.png]](img/Pasted image 20240204013504.png)

## 특징

버블 정렬은 간단하지만 시간 복잡도가 O(n^2)으로 느리기 때문에 대규모 데이터에는 적합하지 않습니다.

## <span style="color:yellow">선택 정렬 (Selection Sort)</span>

선택 정렬은 선형 탐색을 활용한 간단한 정렬 알고리즘 중 하나입니다. 아래의 예시를 통해 선택 정렬의 동작을 살펴보겠습니다.

## 예시

다음과 같은 짝수 배열이 있습니다.

![[Pasted image 20240204014943.png]](img/Pasted image 20240204014943.png)

먼저 선형 탐색을 사용하여 배열에서 가장 작은 숫자를 찾습니다. 이 배열에서 가장 작은 숫자는 2입니다.

![[Pasted image 20240204015024.png]](img/Pasted image 20240204015024.png)

가장 작은 숫자 2와 배열의 가장 왼쪽에 위치한 숫자 12의 위치를 바꿉니다. 그럼 숫자 2는 정렬이 완료된 것으로 간주합니다.

![[Pasted image 20240204015234.png]](img/Pasted image 20240204015234.png)

이러한 동작을 배열의 모든 숫자가 정렬될 때까지 계속 수행합니다. 알고리즘 실행이 끝나면 다음과 같이 정렬된 배열을 얻을 수 있습니다.

![[Pasted image 20240204015456.png]](img/Pasted image 20240204015456.png)



## 특징

- 선택 정렬은 이해하기 쉽지만 시간 복잡도가 $$O(n^{2})$$으로 비효율적입니다.
- 배열의 가장 작은 숫자를 찾기 위해 선형 탐색을 사용하므로 입력 데이터가 많을수록 속도가 느려집니다.

선택 정렬은 작은 배열에서는 잘 동작하지만, 대규모 데이터에는 적합하지 않습니다.



## <span style="color:yellow">삽입 정렬 (Insertion Sort)</span>

삽입 정렬은 간단하면서도 효율적인 정렬 알고리즘 중 하나입니다. 동작은 다음과 같습니다.

1. 배열의 두 번째 숫자부터 시작하여 왼쪽의 숫자들과 비교합니다.
2. 비교하면서 자리를 찾아가며 숫자를 삽입합니다.
3. 배열의 모든 숫자가 정렬될 때까지 위 과정을 반복합니다.

예시

다음과 같이 정렬되지 않은 짝수의 배열이 있습니다.

![[Pasted image 20240204015807.png]](img/Pasted image 20240204015807.png)

삽입 정렬 알고리즘은 왼쪽 끝에서 두 번째에 있는 숫자부터 차례대로 앞의 숫자들과 비교합니다. 처음에는 6과 10을 비교합니다.

![[Pasted image 20240204015906.png]](img/Pasted image 20240204015906.png)

10은 6보다 큰 숫자이므로 두 숫자의 위치를 바꿉니다.

![[Pasted image 20240204015947.png]](img/Pasted image 20240204015947.png)

다음 차례는 왼쪽 끝에서 세 번째에 있는 숫자 8입니다. 알고리즘이 8에 도달하면 앞에 있는 10과 비교합니다.

![[Pasted image 20240204020254.png]](img/Pasted image 20240204020254.png)

10은 8보다 큰 숫자이므로 두 숫자의 위치를 바꿉니다.

![[Pasted image 20240204020322.png]](img/Pasted image 20240204020322.png)

8과 10을 비교한 후에는 8과 6을 비교합니다. 6은 8보다 작은 숫자이므로 두 숫자의 위치를 바꾸지 않습니다. 이러한 동작을 배열의 모든 숫자가 정렬될 때가지 계속 수행합니다. 알고리즘의 실행이 끝나면 다음과 같이 정렬된 배열을 얻을 수 있습니다.

![[Pasted image 20240204020737.png]](img/Pasted image 20240204020737.png)

## 특징

삽입 정렬은 시간 복잡도가 최악의 경우 $$O(n^2)$$이지만, 작은 데이터셋에 대해서는 효율적입니다.

## <span style="color:yellow">셸 정렬 (Shell Sort)</span>

셸 정렬은 삽입 정렬을 보다 효율적으로 실행하는 알고리즘입니다. 다음과 같은 방식으로 동작합니다.

1. 요소를 몇 개 단위로 묶은 후 단위마다 삽입 정렬을 싱행합니다.
2. 이후 단위 요소 수를 줄여 묶은 후 삽입 정렬을 실행합니다.
3. 단위 요소 수가 1이 될 때까지 실행하면 정렬이 완료됩니다.

예시

다음과 같이 정렬되지 않은 짝수의 배열이 있습니다.

![[Pasted image 20240204021459.png]](img/Pasted image 20240204021459.png)

먼저 단위 요소 수를 5로 지정해 삽입 정렬을 각각 실행합니다. 이때 부분 리스트와 삽입 정렬 실행 결과는 다음과 같습니다.

![[Pasted image 20240204022117.png]](img/Pasted image 20240204022117.png)

다음으로 단위 요소 수를 3으로 지정해 삽입 정렬을 각각 실행합니다. 이때 부분 리스트와 삽입 정렬 실행 결과는 다음과 같습니다.

![[Pasted image 20240204022537.png]](img/Pasted image 20240204022537.png)

이번에는 단위 요소 수를 1로 지정해 삽입 정렬을 각각 실행합니다. 이때 부분 리스트와 삽입 정렬 실행 결과는 다음과 같습니다.

![[Pasted image 20240204023136.png]](img/Pasted image 20240204023136.png)

단위 요소 수마다 조금씩 요소를 정렬하므로 최종 단위 요소 수 1일 때는 기존 삽입 정렬보다 위치를 바꾸는 일이 훨씬 적은 것을 알 수 있습니다.
## 특징

셸 정렬은 삽입 정렬에 비해 평균적으로 더 빠른 성능을 보이며, 시간 복잡도는 $$O(n^{1.5})$$ 정도로 추정됩니다.

## <span style="color:red">삽입 정렬과 셸 정렬의 시간 복잡도 비교</span>
| 알고리즘   | 최선       | 평균        | 최악        |
|------------|------------|-------------|-------------|
| 삽입 정렬 | O(n)       | O(n^2)      | O(n^2)      |
| 셸 정렬   | O(n)       | O(n^1.5)    | O(n^2)      |

## <span style="color:yellow">병합 정렬</span>

병합 정렬(merge sort)은 데이터를 반으로 나누어 정렬을 수행하는 독창적인 알고리즘으로, 이를 분할 정복(divide and conquer)이라고 합니다.

## 예시

다음과 같이 정렬되지 않은 짝수의 배열이 있습니다.

![[Pasted image 20240204023957.png]](img/Pasted image 20240204023957.png)

병합 정렬의 첫 번째 과정은 배열을 반으로 나누는 것입니다.

![[Pasted image 20240204024020.png]](img/Pasted image 20240204024020.png)

반으로 나눈 배열을 다시 반으로 나눕니다.

![[Pasted image 20240204024118.png]](img/Pasted image 20240204024118.png)

모든 배열에 하나의 숫자만 남을 때까지 반복해서 반으로 나눕니다.

![[Pasted image 20240204024306.png]](img/Pasted image 20240204024306.png)

두 배열씩 결합하여 작은 숫자에서 큰 숫자 순으로 정렬 합니다.

![[Pasted image 20240204024538.png]](img/Pasted image 20240204024538.png)

결합을 반복하며 점점 배열의 크기를 늘려나갑니다.

![[Pasted image 20240204024810.png]](img/Pasted image 20240204024810.png)

결국 완전히 정렬된 하나의 배열을 얻을 수 있습니다.

![[Pasted image 20240204024838.png]](img/Pasted image 20240204024838.png)

이처럼 병합 정렬은 배열을 나눌 수 없을 때까지 반으로 나눈 다음, 숫자를 정렬하며 더 결합할 수 있는 배열이 없을 때까지 결합하는 알고리즘입니다.

## 특징

병합 정렬은 재귀 함수를 사용하여 입력 데이터를 계속 나누기 때문에 시간 복잡도가 $$O(nlogn)$$입니다. 이는 배열을 반으로 나누고 정렬하는 과정이 로그 시간 복잡도를 갖기 때문입니다.

## <span style="color:yellow">퀵 정렬</span>

분할 정복 방식을 사용하는 또 다른 정렬 알고리즘으로 큌 정렬(quck sort)이 있습니다.

## 예시

다음과 같은 짝수의 배열이 있습니다.

![[Pasted image 20240204025424.png]](img/Pasted image 20240204025424.png)

먼저 배열의 맨 왼쪽 요소를 선택하여 마커 이동의 기준이 되는 **피벗**으로 정합니다. 피벗은 맨 왼쪽 혹은 맨 오른쪽 배열 요소를 피벗으로 선택하도록 합니다.

피벗을 정하고 나면 피벗 바로 오른쪽에 위치한 요소와 배열 맨 오른쪽에 위치한 요소를 선택하여 각각 **왼쪽 마커**와 **오른쪽 마커**로 정합니다. 앞 짝수의 배열이라면 피벗(P)은 6, 왼쪽 마커(L)는 10, 오른쪽 마커(R)는 12입니다.

![[Pasted image 20240204030202.png]](img/Pasted image 20240204030202.png)

왼쪽 마커는 오른쪽으로 이동하며 피벗보다 크거나 같은 첫 번째 숫자를 선택합니다. 마찬가지로 오른쪽 마커는 왼쪽으로 이동하며 피벗보다 작은 첫 번째 숫자를 선택합니다. 이 예에서는 왼쪽 마커에 해당하는 10이 이미 피벗보다 큰 수이므로 움직이지 않고 오른쪽 마커에 해당하는 12는 피벗보다 큰 숫자이므로 오른쪽으로 이동합니다. 앞 예에서는 숫자 4가 있는 요소까지 오른쪽 마커가 계속 이동합니다.

![[Pasted image 20240204030540.png]](img/Pasted image 20240204030540.png)

각 마커가 숫자를 선택하고 나면 왼쪽 마커의 숫자와 오른쪽 마커의 숫자 위치를 바꿉니다.

![[Pasted image 20240204031122.png]](img/Pasted image 20240204031122.png)

핵심은 왼쪽 마커와 오른쪽 마커가 서로 교차하는 상태가  된 후 오른쪽 마커에 해당하는 숫자와 피벗에 해당하는 숫자를 바꾸는 것입니다.

![[Pasted image 20240204032035.png]](img/Pasted image 20240204032035.png)

이렇게 되면 피벗이었던 6의 정렬은 끝난 것입니다.

![[Pasted image 20240204032214.png]](img/Pasted image 20240204032214.png)

이렇게 마커를 사용하여 숫자를 선택하고 위치를 바꾸는 동작을 반복하면 피벗보다 작은 숫자는 배열의 왼쪽에, 피벗보다 큰 숫자는 배열의 오른쪽에 모이게 됩니다.

이제 6의 왼쪽과 오른쪽에 있는 배열의 맨 왼쪽 요소를 새로운 피벗으로 삼아 같은 과정을 반복하면 됩니다.

## 핵심

퀵 정렬은 피벗을 기준으로 왼쪽에는 피벗보다 작은 숫자, 오른쪽에는 피벗보다 큰 숫자로 배열이 정렬되면 알고리즘은 이를 반씩 나눕니다. 그리고 먼저 피벗의 왼쪽 배열에 대해 같은 동작을 수행한 후, 처음 피벗의 오른쪽 배열에 대해서도 같은 동작을 수행합니다. 알고리즘은 배열이 완전히 정렬될 때까지 배열을 작게 나눠가며 정렬을 수행합니다.
큌 정렬의 시간 복잡도는 $$O(nlogn)$$ 입니다.

## <span style="color:yellow">힙 정렬</span>

힙 정렬(heap sort)은 힙 데이터 구조의 각 노드를 최대 힙 혹은 최소 힙 상태로 정렬하는 방법을 뜻합니다.

## 예시

예를 들어 다음과 같이 힙 데이터 구조가 있습니다.

![[Pasted image 20240205002731.png]](img/Pasted image 20240205002731.png)

이를 최대 힙이 되도록 정렬할때 먼저 값이 최대인 11이 있는 노드를 바로 위 부모 노드값 10과 비교합니다. 11이 더 크므로 두 노드의 위치를 바꿉니다.

![[Pasted image 20240205003016.png]](img/Pasted image 20240205003016.png)

다음으로 값이 11인 노드와 바로 위의 값이 4인 부모 노드를 비교합니다. 최대 힙 정렬이므로 값이 11인 노드와 같이 4인 노드의 위치를 바꿉니다.

![[Pasted image 20240205003051.png]](img/Pasted image 20240205003051.png)

이번에는 값이 11인 노드와 루트 노드 값 5를 비교합니다. 역시 값이 11인 노드와 루트 노드의 위치를 바꿉니다.

![[Pasted image 20240205003211.png]](img/Pasted image 20240205003211.png)

다음으로 큰 노드 값은 10입니다. 방금 설명했던 과정과 같은 원리로 값이 10인 노드를 최대 힙 정렬에 맞게 바꾸면 결과는 아래와 같습니다.

![[Pasted image 20240205003309.png]](img/Pasted image 20240205003309.png)


이러한 원리에 따라 모든 노드를 정렬하면 최종 결과는 아래와 같습니다.

![[Pasted image 20240205003343.png]](img/Pasted image 20240205003343.png)

최소 힙 정렬의 원리는 최대 힙 정렬과 반대입니다. 즉, 자식 노드와 부모 노드의 값을 비교해서 더 작은 쪽을 계속 루트 노드에 가깝도록 위치시키는 것입니다. 최소 힙정렬의 결과는 아래와 같습니다.

![[Pasted image 20240205003502.png]](img/Pasted image 20240205003502.png)

힙 정렬은 시간 복잡도가 최선,평균,최악에 상관없이 항상 $$O(nlogn)$$을 유지한다는 장점이 있습니다. 이는 전체 값을 대상으로 비교해 정렬하는 것이 아니라 가장 크거나 작은 값 기준으로 바로 옆에 있는 부모 및 자식 노드를 상대 비교하기 때문입니다.


## <span style="color:yellow">버킷 정렬</span>

버킷 정렬(bucket sort)은 요소들을 어떤 기준이 있는 **버킷**(여러 데이터를 저장하는 장소)에 나눠 넣은 후 다음 과정으로 정렬을 수행합니다.
1. 어떤 순서가 있는 버킷으로 사용할 기억 공간(보통 배열이나 리스트)을 준비합니다.
2. 버킷을 만들 때의 기준에 따라 요소를 분류해 넣습니다.
3. 버킷별로 요소를 정렬합니다.
4. 버킷 안에서 정렬한 요소를 버킷의 순서에 따라 나열해서 정렬을 완료합니다.

## 예시

아래는 숫자로  이루어진 배열입니다.

![[Pasted image 20240205004100.png]](img/Pasted image 20240205004100.png)

이때 보통 다음과 같은 기준으로 생성된 버킷에 요소를 나누어 넣습니다.
그리고 각 버킷 내에서 요소를 정렬한 후 이를 내보냅니다.

![[Pasted image 20240205004516.png]](img/Pasted image 20240205004516.png)

여기서 버킷의 기준은 10진수의 자릿수입니다. 즉, 자릿수를 기준으로 버킷을 만들어 그에 해당하는 요소를 나눠 넣은 후 버킷 안에서 정렬해 정렬 처리 속도를 높인다는 원리입니다.

버킷 정렬의 시간 복잡도는 보통 버킷 내에서 요소를 정렬할 때의 시간 복잡도를 따릅니다. 위와 같은 예라면 보통 삽입 정렬을 사용하므로 최악의 경우 $$O(n^2)$$입니다. 평균은 $$O(n+n^2/m +m)(이때 m은 버킷 수)$$ 입니다.

## <span style="color:yellow">기수 정렬</span>

기수 정렬(radix sort)은 바로 앞에서 설명한 버킷 정렬과 기본 원리는 같습니다.
하지만 특정 기준이 정해져 있는 버킷 정렬이라는 점에 차이가 있습니다. 여기서 특정 기준은 바로 요솟값의 특정 자리수끼리 비교해서 정렬한다는 것입니다.

## 예시

아래는 임의의 배열입니다.

![[Pasted image 20240205004801.png]](img/Pasted image 20240205004801.png)

기수 정렬에서는 이미 숫자 0~9에 해당하는 버킷 9개를 만들고 시작합니다. 그리고 먼저 1의 자릿수를 기준으로 해당 숫자의 버킷 내에 요소를 나눕니다.

![[Pasted image 20240205005710.png]](img/Pasted image 20240205005710.png)

다음으로는 10의 자리수를 기준으로 버킷 내의 요소를 다시 나눕니다. 이때 요솟값이 1의 자리수 숫자라면 그 앞이 0이라고 간주해 요소를 나눕니다.

![[Pasted image 20240205005844.png]](img/Pasted image 20240205005844.png)

이번에는 100의 자릿수를 기준으로 버킷 내의 요소를 다시 나눕니다. 이때 요솟값이 1의 자리수인 숫자와 10의 자리수인 숫자라면 그 앞에 해당하는 자릿수만큼의 0이 있다고 간주해 요소를 나눕니다. 이렇게 계속 요소를 나누다 보면 결국 순소대로 정렬하게 됩니다.

![[Pasted image 20240205005452.png]](img/Pasted image 20240205005452.png)

기수 정렬의 시간 복잡도는 최악의 경우 $$O(mn)(m은 요소의 자릿수)$$ 입니다.